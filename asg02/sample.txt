Programming assignment 2: Building a Reliable Transport Protocol
Due: Wednesday, April 10th, 2013 
1. Description

The goal of this assignment in this laboratory programming assignment is to use a guided, building block approach to write the sending and receiving transport-level code for an implementation of the simple reliable data transfer protocol (rtd 3.0). Remember, the transport level is responsible for passing messages between the application layer and network layer on a host in order to allow two processes to communicate.

2. Implementation

Since we canï¿½t modify the Linux operating system on our lab computers, your code will have to execute as a library at the application layer. However, the programming interface provided to your routines, i.e., the code that would call your entities from above and from below is very close to what is done in an actual UNIX environment. Stopping/starting of timers is also virtual, and timer interrupts will cause your timer handling routine to be activated.

The routines you will write are for the sending entity (A) and the receiving entity (B). Only unidirectional transfer of data (from A to B) is required. However, the B side will ultimately have to send packets to A to acknowledge receipt of data.

In this assignment, you are to provide a library (librdt.a) and a header file (rdt.h) to be used by the application program.

In general your implementation should:

    Handle packet drops.
    Handle packet corruption.
    Provide a stream abstraction.
    Detect any single-bit errors in packets.

You will implement both the client and server component of a transport layer. The client will read a stream of data in (either from STDIN or a file), break it into fixed-sized packets suitable for UDP transport, prepend a control header to the data, and write this packet to the server. The server will read these packets and write the corresponding data, in order, to a reliable stream (STDOUT  or a file).
Packet types and fields

There are two kinds of packets, Data packets and Ack-only packets. You can tell the type of a packet by its length. Ack packets are 8 bytes, while Data packets vary from 12 to 512 bytes. The packet format is defined in rlib.h:

        struct packet {
          uint16_t cksum; /* Ack and Data */
          uint16_t len;   /* Ack and Data */
          uint32_t ackno; /* Ack and Data */
          uint32_t seqno; /* Data only */
          char data[500]; /* Data only; Not always 500 bytes, can be less */
        };
        typedef struct packet packet_t;

Every Data packet contains a 32-bit sequence number as well as 0 or more bytes of payload. The length, seqno, and ackno fields are always in network byte order (meaning you will have to use htonl/htons to write those fields and ntohl/ntohs to read them). Both Data and Ack packets contain the following fields:

cksum

    16-bit IP checksum 
len

    16-bit total length of the packet. This will be 8 for Ack packets, and 12 + payload-size for data packets (since 12 bytes are used for the header). An end-of-file condition is transmitted to the other side of a connection by a data packet containing 0 bytes of payload, and hence a len of 12. Note: You must examine the length field, and should not assume that the UDP packet you receive is the correct length. The network might truncate or pad packets.
ackno

    32-bit cumulative acknowledgment number. This says that the sender of a packet has received all packets with sequence numbers earlier than ackno, and is waiting for the packet with a seqno of ackno. Note that the ackno is the sequence number you are waiting for, that you have not received yet. The first sequence number in any connection is 1, so if you have not received any packets yet, you should set the ackno field to 1.

The following fields only exist in a data packet:

seqno

    Each packet transmitted in a stream of data must be numbered with a seqno. The first packet in a stream has seqno 1. Note that in TCP, sequence numbers indicate bytes. By contrast, this protocol just numbers packets. That means that once a packet is transmitted, it cannot be merged with another packet for retransmission. This should simplify your implementation.
data

    Contains (len - 12) bytes of payload data for the application.

Requirements

Your transport layer must support the following:

    Each side's output should be identical to the other side's input, regardless of a lossy, congested, or corrupting network layer. You will ensure reliable transport by having the recipient acknowledge packets received from the sender; the sender will detect missing acknowledgments and resend the dropped or corrupted packets.

    As reliable transport is inherently a stateful protocol, your transport layer should handle simple connection establishment. In this assignment, the server can detect a new connection when it receives a packet with a sequence number of 1 (which should always be the sequence number of the first packet in a new connection).

    You should handle connection teardown properly. When you read an EOF, you should send a zero-length payload (12-byte packet) to the other side to indicate the end of file condition. When you receive a zero-length payload (and have written the contents of all previous packets), you should send an EOF to your output by calling conn_output with a len of 0.

     Have the window size to be just one packet (the default). 

    Your server and client should ensure that data is written in the correct order, even if the network layer reordered packets. 

    The sender should resend a packet if the receiver does not acknowledge it within an appropriate time period. You need not implement any backoff like TCP, and can instead merely send packet(s) whenever a sent packet has gone unacknowledged for the timeout period. The timeout period in milliseconds is supplied to you by the timeout field of the config_common structure. The default is 2000 msec, but you may change this with the -t command-line option.

    You can retry packets infinitely many times, and should make sure you retry at least FIVE times, after which, if you want, the client can terminate the connection with an error. 

    Note: For debugging printfs you should use the Standard Error fprintf (stderr, ...) and not print on standard output. This is because standard output is being used for the actual program output and it will be confusing for the grader as well as the tester.

Implementation Details

You are to provide a library (librdt.a) and your task is to implement the following four functions: rdt_create, rdt_destroy, rdt_recv,  rdt_send.

    The rdt_socket() function is used to create an end point for communications.

     int rdt_socket(int address_family,
            	    int type,
             	    int protocol)

    The rdt_bind() function is used to associate a local address with a socket

      int rdt_bind(int socket_descriptor,
          	   const struct sockaddr *local_address,
          	   socklen_t address_length)

    The rdt_recv() function is used to receive data through an unconnected socket.

      int rdt_recv(int socket_descriptor,
              	   char *buffer,
                   int buffer_length,
                   int flags,
                   struct sockaddr *from_address,
                   int *address_length)

    The rdt_send() function is used to send data through a connected or unconnected socket

      int rdt_sendto(int socket_descriptor,
            	     char *buffer,
            	     int buffer_length,
            	     int flags,
           	     struct sockaddr *destination_address,
            	     int address_length)

    The rdt_close() function closes a descriptor, fildes

           int close(int fildes);

 
Submission

You will write C++ (or C) code that compiles under the GCC (GNU  Compiler Collection) environment. You have to make sure your code will compile  and run correctly on the  the CS department's Linux  machines. You should submit both your server and the client you used to test your  server. Please remove all object files and submit only source codes with a make  file. Add a readme.txt file describing how to compile and run your program  from a terminal. Submit your assignment files, including your report, by the due date
Grading Criteria and Demo

 Students will demonstrate their projects after  the due date of the assignment. Students should prepare a 5-10 minutes demo
